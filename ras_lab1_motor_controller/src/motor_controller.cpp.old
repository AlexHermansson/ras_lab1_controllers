#include <ros/ros.h>
#include <vector>
#include <math.h>
#include <ras_lab1_msgs/PWM.h>
#include <ras_lab1_msgs/Encoders.h>
#include <geometry_msgs/Twist.h>

const int control_frequency = 10;
const int ticks_per_rev = 360;
const double wheel_radius = 0.0352;
const double base = 0.23; 

class Controller {

	public:

		std::vector<double> int_error; //integrated error
		double v_robot_desired;
		double w_robot_desired;
		std::vector<double> w_wheel_desired;
		std::vector<double> w_wheel_estimate;
		std::vector<int> delta_encoder;
		
	Controller() {
		int_error(2);
		w_wheel_desired(2);
		w_wheel_estimate(2);
		delta_encoder(2);
	}

	void encoderCallback(const ras_lab1_msgs::Encoders::ConstPtr& msg) {
		delta_encoder[0] = msg->delta_encoder1;
		delta_encoder[1] = msg->delta_encoder2;
	}
	
	void twistCallback(const geometry_msgs::Twist::ConstPtr& msg) {
		v_robot_desired = msg->linear.x;
		w_robot_desired = msg->angular.z;
	}
	
	void estimateSpeed() {
		w_wheel_estimate[0] = (delta_encoder[0] * 2 * M_PI * control_frequency) / (ticks_per_rev);
		w_wheel_estimate[1] = (delta_encoder[0] * 2 * M_PI * control_frequency) / (ticks_per_rev);
	}
	
	std::vector<int> getPWM() {
		double error_left = w_wheel_desired[0] - w_wheel_estimate[0];
		int_error[0] += error_left;
		int pwm_left = std::round(alpha * error_left + beta * int_error[0];)
		
		double error_right = w_wheel_desired[1] - w_wheel_estimate[1];
		int_error[1] += error_right;
		int pwm_right = std::round(alpha * error_right + beta * int_error[1];)
		
		std::vector<int> pwm_out = {pwm_left, pwm_right};
		
		return pwm_out
	}
		
};


int main(int argc, char **argv)
{	
	ros::init(argc, argv, "motor_controller");
	ros::NodeHandle nh;
	ros::Rate rate(10);
	
	Controller controller = Controller();
	
	ros::Publisher pwm_pub = nh.advertise<ras_lab1_msgs::PWM>("/kobuki/pwm", 1);
	
	ros::Subscriber enc_sub = nh.subscribe<ras_lab1_msgs::Encoders>("/kobuki/encoders", 1, encoderCallback);
	
	ros::Subscriber twist_sub = nh.subscribe<geometry_msgs::Twist>("/motor_controller/twist", 1, twistCallback);
	
	ras_lab1_msgs::PWM pwm_msg;
	
	while (ros::ok()) {
	
		/*  
		Subscriber listens to the encoder and twist. Updates desired v and w, then updates the
		delta encoder values.
		*/
		ros::spinOnce(); 
		
		
		setPWM(pwm_msg);
		pwm_pub.publish(pwm_msg);
		
		rate.sleep();
		
		
	}
	
}
